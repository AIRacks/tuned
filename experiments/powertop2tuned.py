#! /usr/bin/python
#
# Copyright (C) 2012 Red Hat, Inc.
# Authors: Jan Kaluza <jkaluza@redhat.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#

import os
import sys
import tempfile
import shutil
import argparse
from subprocess import *
from HTMLParser import HTMLParser
from htmlentitydefs import name2codepoint

SCRIPT_SH = """#!/bin/sh

. /usr/lib/tuned/functions

start() {
%s
	return 0
}

stop() {
%s
	return 0
}

process $@
"""

TUNED_CONF_PROLOG = "# Automatically generated by powertop2tuned tool"
TUNED_CONF_INCLUDE = """[main]
%s
"""
TUNED_CONF_EPILOG="""[powertop_script]
type=script
script=script.sh
"""


class PowertopHTMLParser(HTMLParser):
	def __init__(self, enable_tunings):
		HTMLParser.__init__(self)

		self.inProperTable = False
		self.inScript = False
		self.lastStartTag = ""
		self.tdCounter = 0
		self.lastDesc = ""
		self.data = ""
		if enable_tunings:
			self.prefix = ""
		else:
			self.prefix = "#"

	def getParsedData(self):
		return self.data

	def handle_starttag(self, tag, attrs):
		self.lastStartTag = tag
		if self.inProperTable and tag == "td":
			self.tdCounter += 1

	def handle_endtag(self, tag):
		if self.inProperTable and tag == "table":
			self.inProperTable = False
		if tag == "tr":
			self.tdCounter = 0
		if self.inScript:
			self.inScript = False
			self.data += "\n\n"

	def handle_entityref(self, name):
		if self.inScript:
			self.data += unichr(name2codepoint[name])

	def handle_data(self, data):
		prefix = self.prefix
		if self.lastStartTag == "h2" and data == "Software settings in need of tuning":
			self.inProperTable = True
		if self.inProperTable and self.tdCounter == 1:
			self.lastDesc = data
			if self.lastDesc.lower().find("autosuspend") != -1 and (self.lastDesc.lower().find("keyboard") != -1 or self.lastDesc.lower().find("mouse") != -1):
					self.lastDesc += "\n\t# WARNING: For some devices, uncommenting this command can disable the device."
					prefix = "#"
		if (self.inProperTable and self.tdCounter == 2) or self.inScript:
			self.tdCounter = 0
			if not self.inScript:
				self.data += "\t# " + self.lastDesc + "\n"
				self.data += "\t" + prefix + data
				self.inScript = True
			else:
				self.data += data

class PowertopProfile:
	BAD_PRIVS = 100
	PARSING_ERROR = 101
	BAD_SCRIPTSH = 102

	def __init__(self, output, name = ""):
		self.name = name
		self.output = output

	def currentActiveProfile(self):
		proc = Popen(["tuned-adm", "active"], stdout=PIPE)
		output = proc.communicate()[0]
		if output and output.find("Current active profile: ") == 0:
			return output[len("Current active profile: "):output.find("\n")]
		return "unknown"

	def checkPrivs(self):
		myuid = os.getuid()
		if myuid != 0:
			print >> sys.stderr, 'Run this program as root'
			return False
		return True

	def generateHTML(self):
		f = tempfile.NamedTemporaryFile()
		name = unicode(f.name)
		f.close()
		
		ret = os.system('powertop --html="%s"' % (name))
		if ret != 0:
			os.unlink(name)
			return ret

		return name;

	def parseHTML(self, enable_tunings):
		f = open(self.name)
		parser = PowertopHTMLParser(enable_tunings)
		parser.feed(f.read())
		f.close()

		return parser.getParsedData()

	def generateShellScript(self, profile, data):
		print "Generating shell script", os.path.join(self.output, "script.sh")
		f = open(os.path.join(self.output, "script.sh"), "w")
		f.write(SCRIPT_SH % (data, ""))
		os.fchmod(f.fileno(), 0755)
		f.close()
		return True

	def generateTunedConf(self, profile, new_profile):
		print "Generating Tuned config file", os.path.join(self.output, "tuned.conf")
		f = open(os.path.join(self.output, "tuned.conf"), "w")
		f.write(TUNED_CONF_PROLOG)
		if (new_profile):		
			f.write(TUNED_CONF_INCLUDE % ("include=" + profile))
		f.write(TUNED_CONF_EPILOG)
		f.close()

	def generate(self, new_profile, enable_tunings):
		generated_html = False
		if len(self.name) == 0:
			generated_html = True
			if not self.checkPrivs():
				return self.BAD_PRIVS

			name = self.generateHTML()
			if isinstance(name, int):
				return name
			self.name = name

		data = self.parseHTML(enable_tunings)

		if generated_html:
			os.unlink(self.name)

		if len(data) == 0:
			print >> sys.stderr, 'Your Powertop version is incompatible (maybe too old) or the generated HTML output is malformed'
			return self.PARSING_ERROR

		profile = self.currentActiveProfile()

		if not os.path.exists(self.output):
			os.makedirs(self.output)

		if not self.generateShellScript(profile, data):
			return self.BAD_SCRIPTSH

		self.generateTunedConf(profile, new_profile)

		return 0

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Creates Tuned profile from Powertop HTML output.')
	parser.add_argument('profile', metavar='profile_name', type=unicode, nargs='?', help='Name for the profile to be written.')
	parser.add_argument('-i', '--input', metavar='input_html', type=unicode, help='Path to Powertop HTML report. If not given, it is generated automatically.')
	parser.add_argument('-o', '--output', metavar='output_directory', type=unicode, help='Directory where the profile will be written, default is /etc/tuned/profile_name directory.')
	parser.add_argument('-n', '--new-profile', action='store_true', help='Creates new profile, otherwise it merges (include) your current profile.')
	parser.add_argument('-f', '--force', action='store_true', help='Overwrites the output directory if it already exists.')
	parser.add_argument('--enable', action='store_true', help='Enable all tunings (not recommended). Even with this enabled tunings known to be harmful (like USB_AUTOSUSPEND) won''t be enabled.')
	args = parser.parse_args()
	args = vars(args)

	if not args['profile'] and not args['output']:
		print >> sys.stderr, 'You have to specify the profile_name or output directory using the --output argument.'
		parser.print_help()
		sys.exit(-1)

	if not args['output']:
		args['output'] = "/etc/tuned"	

	if args['profile']:
		args['output'] = os.path.join(args['output'], args['profile'])

	if not args['input']:
		args['input'] = ''

	if os.path.exists(args['output']) and not args['force']:
		print >> sys.stderr, 'Output directory already exists, use --force to overwrite it.'
		sys.exit(-1)

	p = PowertopProfile(args['output'], args['input'])
	sys.exit(p.generate(args['new_profile'], args['enable']))

